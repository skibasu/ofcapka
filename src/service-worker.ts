/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core"
import { ExpirationPlugin } from "workbox-expiration"
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { CacheFirst, StaleWhileRevalidate } from "workbox-strategies"

declare const self: ServiceWorkerGlobalScope

// Make the service worker take control of the page as soon as possible
clientsClaim()

// Precache all of the assets generated by your build process.
// The URLs are injected into the manifest below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching.
precacheAndRoute(self.__WB_MANIFEST)

// Set up App Shell-style routing, so all navigation requests
// are fulfilled with the index.html shell.
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$")
registerRoute(
    // Only handle navigation requests (i.e., page loads)
    ({ request, url }: { request: Request; url: URL }) => {
        // If the request is not a navigation, skip it
        if (request.mode !== "navigate") {
            return false
        }

        // If the URL starts with /_, skip it (e.g., API routes)
        if (url.pathname.startsWith("/_")) {
            return false
        }

        // If the URL contains a file extension, skip it
        if (url.pathname.match(fileExtensionRegexp)) {
            return false
        }

        // Return true to allow the route handler to respond with index.html
        return true
    },
    createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
)

// Cache runtime resources like images or API responses
// Here is an example of caching API responses:
registerRoute(
    ({ url }) => url.pathname.startsWith("/api/"), // Cache requests that start with /api/
    new StaleWhileRevalidate({
        cacheName: "api-cache",
        plugins: [
            new ExpirationPlugin({
                maxEntries: 50, // Cache up to 50 entries
                maxAgeSeconds: 5 * 60, // Cache for 5 minutes
            }),
        ],
    })
)

// Cache image resources such as JPG, PNG, and SVG
registerRoute(
    ({ request }) => request.destination === "image", // Cache requests for images
    new CacheFirst({
        cacheName: "image-cache",
        plugins: [
            new ExpirationPlugin({
                maxEntries: 100, // Cache up to 100 images
                maxAgeSeconds: 30 * 24 * 60 * 60, // Cache for 30 days
            }),
        ],
    })
)

// Additional caching specifically for SVG files
registerRoute(
    ({ url }) => url.pathname.endsWith(".svg"), // Specifically handle SVG files
    new CacheFirst({
        cacheName: "svg-cache",
        plugins: [
            new ExpirationPlugin({
                maxEntries: 50, // Cache up to 50 SVGs
                maxAgeSeconds: 60 * 60 * 24 * 7, // Cache for 7 days
            }),
        ],
    })
)

// Handle Service Worker updates: trigger skipWaiting
self.addEventListener("message", (event) => {
    if (event.data && event.data.type === "SKIP_WAITING") {
        self.skipWaiting()
    }
})

// You can add any additional Service Worker logic here
